======== Random ========
-because the bytecode interpreter is implemented in a high level language, high level functions can be directly implemented
-to simplify operation and improve performance, each instance's memory functions as registers, RAM, and long term storage
-interface with logic, storage, computer, and factory blocks is performed by linking them to a programmable block
-interface with ship systems is performed by physically contacting a listener block to the shapeless ship system structure to
 communicate with and linking it to a programmable block (allows for scripted reactor switching)
-block interface API should be kept generic somehow (do blocks have specific API functions?, ???)
-IO based on block link "direction" or should linking blocks to the programmable block suffice?

== Interpreter Structure ==
Instances:
 -stored in programmable block information
 -made up of:
  script source string
  compiled bytecode array
  memory array
  instruction pointer
  linked block array
  compiled state variable
Interpreter:
 -compiles and executes bytecode sequences
 -made up of:
  script compiler (could be implemented to compile a string over time instead of at once)
  interpreter
Execution steps:
 -when the "compile" button for a programmable block has been pressed, the interpreter's compile function is called
 -when the block has received a logic signal or is manually ran, queue the block ID
 -loop through block queue (does starmade do that? Sounds slow. Gotta look at the stldr wiki)
    1) if the compile state is false, send an error message and remove from queue
    2) get the current instruction using the instruction pointer for the current instance
    3) split the instruction up into its components
    4) determine type of instruction and further divide it
    5) use the components to execute it

=========== ISA ===========

===== Memory/Registers ====

========= Opcodes =========
